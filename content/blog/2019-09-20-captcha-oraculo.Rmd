---
title: "Quebrando Captchas - Parte VII: Oráculos"
date: "2019-10-11"
categories: ["r", "tutoriais"]
tags: ["r", "captcha"]
banner: "img/banners/captcha_07.png"
author: ["Julio"]
summary: "Nesse post não vou falar da companhia Oracle, muito menos de Pythia, a oráculo de Delphi. Aqui vou mostrar uma parte pouco discutida dos captchas, que é a possibilidade de usar oráculos para aprender."
draft: false
editor_options: 
  chunk_output_type: inline
---

```{r, echo=FALSE, eval=FALSE, include=FALSE}
image_read('../../static/img/banners/captcha_01.png') %>%
  image_crop("420x100+0+101") %>%
  image_border(color = 'white', "0x108") %>%
  image_noise() %>%
  image_noise() %>%
  image_annotate('#6', size = 80, font = 'ubuntu',
                 location = '+300+10', color = 'red') %>%
  image_annotate('Oráculos', size = 40, font = 'ubuntu',
                 color = 'black', location = '+10+240') %>%
  image_write("../../static/img/banners/captcha_07.png")
```

Um oráculo é uma função que diz para você se uma predição está correta ou incorreta. A diferença entre um oráculo e a sua base de teste é que o oráculo pode gerar infinitas novas observações da base, de forma que você pode criar uma base de dados de treino virtualmente infinita.

O problema é que a resposta do oráculo não é sempre clara: usualmente, o oráculo não diz __o quê__ você errou, mas somente __se__ você errou. Ou seja, é uma informação incompleta. E como nós fazemos para tratar informação incompleta nos nossos estudos? Botamos na verossimilhança! 

Essa é uma possível ideia para resolver captchas automaticamente, pois nós temos um oráculo. Mas tem muitos problemas ainda a serem resolvidos. Nesse post vou me ater ao funcionamento de um oráculo.

## Construindo um oráculo

Um oráculo precisa ter três partes implementadas

1. obtenção de uma imagem nova
2. teste do modelo
3. retorno

## Modelo

Meu modelo é uma rede neural convolucional simples, exatamente igual a que está no `decryptr`. Essa rede foi treinada com 10 mil observações do MNIST, o que dá uma taxa de acerto de 95% de cada captcha (ou seja, acertar 6 letras).

A pergunta que eu quero responder é: será que dá para usar a informação do oráculo de alguma forma no meu modelo?

```{r}
library(keras)

data <- list(
  x = array(NA, dim = c(10000, 24, 24*6, 1)),
  y = array(NA, dim = c(10000, 6, 10))
)

input <- layer_input(shape = dim(data$x)[-1])

my_conv <- function(obj, f) {
  obj %>% 
    layer_conv_2d(
      filters = 32, 
      kernel_size = c(5, 5), 
      padding = "same", 
      activation = "relu"
    ) %>% 
    layer_max_pooling_2d()
}

n_units <- 64

output <- input %>% 
  my_conv(16) %>% 
  my_conv(32) %>% 
  my_conv(64) %>% 
  layer_flatten() %>% 
  layer_dense(units = n_units) %>% 
  layer_dropout(.1) %>% 
  layer_dense(units = prod(dim(data$y)[-1])) %>% 
  layer_reshape(target_shape = dim(data$y)[-1]) %>% 
  layer_activation("softmax")

modelo <- keras_model(input, output)

```

## Pacote mimir

Estou montando um pacote `{mimir}` para construir e trabalhar com oráculos. O nome Mimir vem da figura da mitologia nórdica, conhecida por ser muito sábia. Eu achei o nome legal pois i) mimi lembra gatos, o que interage bem com as brincadeiras `purrr` e `forcats` e ii) por ter um R no final, que é sempre legal em pacotes!

No próximo post do tema, vou apresentar algumas formas de aproveitar a informação do oráculo na verossimilhança e alguns testes que venho desenvolvendo.

É isso pessoal. Happy coding ;)
