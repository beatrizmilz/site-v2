---
title: "Gráficos com ggplot2"
author: "Curso-R"
date: 2018-07-18
categories: ["R"]
tags: ["ggplot"]
slug: "ggplot"
minidesc: "Faça gráficos de maneira intuitiva com o pacote ggplot2"
desc: "Visualizar os dados é um dos passos mais importantes na análise de dados. O pacote ggplot2 implementa a gramática dos gráficos permitindo que você produza qualquer gráfico de forma muito intuitiva."
requisitos: ["r-base"]
layout: "article"
ordem: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, out.width = "75%")
```

# Introdução

Agora que já temos em mãos as ferramentas para importar, arrumar e transformar os nossos dados, é hora de começarmos a extrair informações deles. Seguindo o nosso bom e velho ciclo da ciência de dados, o próximo passo é a construção de *visualizações*.

```{r transform, echo=FALSE, fig.align='center'}
knitr::include_graphics('figures/ciclo-ciencia-de-dados.png')
```

A visualização dos dados é uma etapa importantíssima da análise estatística, pois é a partir dela que criamos a intuição necessária para escolher o teste ou modelo mais adequado para o nosso problema.

Visualizações podem ser uma simples medida resumo (frequência, média, variância, mínimo, máximo, ...), um conjunto dessas medidas organizadas em uma tabela ou a representação (de uma parte) dos dados em um gráfico. Nesse tópico, focaremos na construção de gráficos, uma tarefa que, apesar de nem sempre ser conceitualmente ou tecnicamente trivial, é muito facilitada pelas ferramentas disponíveis no R.

Mas, antes de mais nada, o que é um gráfico estatístico?

# O que é um gráfico?

A construção de gráficos no R foi revolucionada com a criação do pacote `ggplot2`, fruto da tese de doutorado de [Hadley Wickham](https://github.com/hadley). Essa revolução teve base na filosofia adotada por Hadley ao definir o que deveria ser um gráfico estatístico.

Mas será que podemos definir formalmente o que é um gráfico estatístico? Graças ao estatístico norte-americano Leland Wilkinson, a resposta é sim.

Em 2005, Leland publicou o livro [*The Grammar of graphics*](http://www.springer.com/statistics/computational+statistics/book/978-0-387-24544-7), uma fonte de princípios fundamentais para a construção de gráficos estatísticos. No livro, ele defende que um gráfico é o mapeamento dos dados a partir de atributos estéticos (posição, cor, forma, tamanho) de objetos geométricos (pontos, linhas, barras, caixas).

A partir dessa definição, Hadley escreveu [A Layered Grammar of Graphics](http://vita.had.co.nz/papers/layered-grammar.html), sugerindo que os principais aspectos de um gráfico (dados, sistema de coordenadas, rótulos e anotações) podiam ser divididos em camadas, construídas uma a uma na elaboração do gráfico. Essa é a essência do `ggplot2`.

Além de uma filosofia bem fundamentada, o `ggplot2` ainda traz outras vantagens em relação aos gráficos do r base:

- gráficos naturalmente mais bonitos;
- muito mais fácil deixar o gráfico do jeito que você quer;
- a estrutura padronizada das funções deixa o aprendizado muito mais intuitivo; e
- é possível criar uma imensa gama de gráficos com poucas linhas de código.

Para discutir os principais aspectos da construção de gráficos com o `ggplot2`, vamos continuar utilizando a base de filmes do IMDB apresentada na [seção de manipulação](https://www.curso-r.com/material/manipulacao/). Você pode baixá-la [clicando aqui](https://github.com/curso-r/site-v2/raw/master/content/material/importacao/data/imdb.rds).

Na próxima seção, vamos conhecer as principais funções do `ggplot2` e começar a construir nossos primeiros gráficos. Não se esqueça de instalar e carregar o pacote antes de rodar os exemplos.

```{r, eval=FALSE}
install.packages("ggplot2")
library(ggplot2)
```

```{r, echo=FALSE}
library(ggplot2)
```

# As camadas de um gráfico

No `ggplot2`, os gráficos são construídos camada por camada, sendo a primeira delas dada pela função `ggplot()` (repare que não tem o "2"). Essa função recebe um data frame e cria a camada base do gráfico. Se rodarmos apenas a função `ggplot()`, obteremos um painel em branco.

```{r}
imdb <- readr::read_rds("data/imdb.rds")

ggplot(data = imdb)
```

Apesar de termos passados os dados para a função, precisamos especificar como as observações serão mapeadas nos aspectos visuais do gráfico e quais formas geométricas serão utilizadas para isso. Cada camada do gráfico representará um tipo de mapeamento ou personalização. 

O código abaixo constrói um gráfico de dispersão entre as variáveis orçamento e receita.

```{r}
ggplot(imdb) +
  geom_point(aes(x = orcamento, y = receita))
```

Observe que:

- como vimos, a primeira camada é dada pela função `ggplot()` e recebe um data frame;
- a segunda camada é dada pela função `geom_point()`, especificando a forma **geom**étrica utilizada no mapeamento das observações;
- as camadas são unidas com um `+`;
- o mapeamento na função `geom_point()` recebe a função `aes()`, responsável por descrever como as variáveis serão mapeadas nos aspectos visuais da forma geométrica escolhida, no caso, pontos.

A combinação da função `ggplot()` e de uma ou mais funções `geom_()` definirá o tipo de gráfico gerado.

**Atenção!** As camadas dos gráficos são empilhadas utilizando-se o sinal `+`. Como a estrutura é muito parecida com uma pipe line, é comum trocarmos o `+` por um `%>%` no meio do código, resultando em erro.

Podemos acrescentar uma terceira camada ao gráfico, gerando a reta `y = x` para visualizarmos os filmes não se pagaram.

```{r}
ggplot(imdb) +
  geom_point(mapping = aes(x = orcamento, y = receita)) +
  geom_abline(intercept = 0, slope = 1, color = "red")
```

Assim, os pontos abaixo da reta representam os filmes com orçamento maior que a receita, isto é, aqueles que deram prejuízo.

Em vez de utilizarmos a reta `y = x`, podemos pintar os pontos que deram lucro e prejuízo de cores diferentes.

```{r}
library(dplyr)

imdb %>%
   mutate(
    lucro = receita - orcamento,
    lucro = ifelse(lucro <= 0, "Não", "Sim")
  ) %>% 
  filter(!is.na(lucro)) %>% 
  ggplot() + 
  geom_point(mapping = aes(x = orcamento, y = receita, color = lucro))
```

Aqui temos dois pontos importantes:

1. Unimos uma primeira parte de manipulação, utilizando as funções `filter()` e `mutate()`, com o código do gráfico. Essa etapa inicial de transformação da base é muito comum na construção de gráficos.

2. A cor dos pontos foi alterada por meio do atributo `color=`, dentro da função `aes()`.

Também podemos adicionar uma camada especificando os textos que representam cada atributo. Para isso, usamos a função `labs()`.

```{r}
imdb %>%
  mutate(
    lucro = receita - orcamento,
    lucro = ifelse(lucro <= 0, "Não", "Sim")
  )  %>%
  filter(!is.na(lucro)) %>% 
  ggplot() +
  geom_point(mapping = aes(x = orcamento, y = receita, color = lucro)) +
  labs(x = "Orçamento", y = "Arrecadação", color = "Houve lucro?") 
```

No ggplot, nós modificamos um gráfico alterando e acrescentando camadas. Agora que você já sabe como essa estrutura funciona, vamos estudar com mais atenção para que serve a função `aes()`.

# Atributos estéticos

O papel da função `aes()` (de *aesthetics*, estética em inglês) é indicar a relação entre os dados e cada aspecto visual do gráfico, como qual variável será representada no eixo x, qual será representada no eixo y, a cor e o tamanho dos componentes geométricos etc. Os aspectos que podem ou devem ser mapeados depende do tipo de gráfico que você está construindo.

Segue abaixo uma lista dos aspectos visuais mais utilizados:

- `color=`: altera a cor de formas que não têm área (pontos e retas).
- `fill=`: altera a cor de formas com área (barras, caixas, densidades, áreas).
- `size=`: altera o tamanho de formas.
- `type=`: altera o tipo da forma, geralmente usada para pontos.
- `linetype=`: altera o tipo da linha.

Um erro comum na hora de definir atributos estéticos de um gráfico é utilizar a função `aes()` de forma errada. Repare o que acontece quando tentamos definir diretamente a cor dos pontos dentro dessa função.

```{r}
ggplot(imdb) +
  geom_point(aes(x = orcamento, y = receita, color = "blue"))
```

Estranho, não? O que aconteceu foi o seguinte: a função `aes()` espera uma variável para ser mapeada a cada atributo, então o valor `blue` é tratado como uma nova variável/coluna que tem essa string para todas as observações. Assim, todos pontos têm a mesma cor (vermelha, padrão do ggplot) pois pertencem todos à essa "categoria 'blue'".

No caso, o que gostaríamos é de ter pintado todos os pontos de azul. A forma certa de fazer isso é colocando o atributo `color=` fora da função `aes()`: 

```{r}
ggplot(imdb) +
  geom_point(aes(x = orcamento, y = receita), color = "blue")
```

Vamos agora explorar novos gráficos a partir da família de funções `geom_()`.

# Formas geométricas

Os *geoms* definem qual forma geométrica será utilizada para a visualização das observações. Como já vimos, a função `geom_point()` gera gráficos de dispersão
transformando pares $(x,y)$ em pontos. Veja a seguir outros *geoms* bastante utilizados:

- `geom_line` - para linhas definidas por pares (x,y).
- `geom_abline` - para retas definidas por um intercepto e uma inclinação.
- `geom_hline` - para retas horizontais.
- `geom_bar` - para barras.
- `geom_histogram` - para histogramas.
- `geom_boxplot` - para boxplots.
- `geom_density` - para densidades.
- `geom_area` - para áreas.

Veja a seguir como é fácil gerar diversos gráficos diferentes utilizando a mesma estrutura do gráfico de dispersão acima:

### Linhas

```{r}
imdb %>% 
  filter(diretor == "Steven Spielberg") %>%
  group_by(ano) %>% 
  summarise(nota_media = mean(nota_imdb, na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x = ano, y = nota_media))
```


### Histograma

```{r}
ggplot(imdb) + 
  geom_histogram(aes(x = orcamento), color = "black", fill = "white")
```

Enquanto o gráfico e dispersão demandam o mapeamento das posições x e y, o histograma requer apenas a posição x, já que, pela definição do gráfico, o eixo mostra a frequência de cada classe.

### Boxplot

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>% 
ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita))
```

Repare que o boxplot pede uma variável categórica no eixo x.

### Gráfico de barras

Há duas formas de fazer um gráfico de barras. A primeira é utilizando a função `geom_bar()`, quando queremos que a função conte a frequência de cada categoria.

```{r}
imdb %>% 
  filter(ano > 1990) %>% 
  ggplot() +
  geom_bar(aes(x = ano), color = "black", fill = "light blue")
```

Ou a função `geom_col()`, quando já temos essas contagens.

```{r}
imdb %>% 
  count(diretor) %>% 
  filter(!is.na(diretor)) %>% 
  dplyr::top_n(5, n) %>%
  ggplot() +
  geom_bar(
    aes(x = diretor, y = n), 
    stat = "identity", 
    color = "red", 
    fill = "pink"
  )
```


# Juntando gráficos



# Facets

Uma funcionalidade muito útil do `ggplot2` é a possibilidade de usar `facets`.
Isso auxilia na visualização de diferentes subconjuntos dos dados em gráficos
separados, permitindo a visualização de comportamentos diferentes dependendo
do grupo.

```{r}
ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point() +
  geom_smooth(method = "lm") + 
  facet_wrap(~am)
```

No gráfico acima, rapidamente conseguimos visualizar que se o carro não é automático o consumo de combustível é muito menor do que quando o carro é automático. Também conseguimos ver que a inclinação das retas é bem diferente dependendo do carro ser
automático/manual.

**Exercício**: pesquisar o que faz a função `facet_grid()`.

# Personalizando

Como exemplo de personalização de um gráfico com o `ggplot2`, vamos partir de um simples boxplot e fazer diversas alterações nas legendas. 

Para isso, utilizaremos nessa seção a base contida no objeto `PlantGrowth`, contendo resultados de um experimento para comparar o crescimento de plantas sob três condições diferentes (um controle e dois tratamentos). Para mais informações, rode `help(PlantGrowth)`.

O gráfico inicial é construído da seguinte forma:

```{r}
bp <- ggplot(data = PlantGrowth, aes(x = group, y = weight, fill = group)) +
  geom_boxplot()

bp
```

## Removendo totalmente a legenda

Existem diversas maneiras para remover a legenda de um gráfico no `ggplot2`. A forma mais simples é usar `guides(fill = FALSE)` com `fill` sendo o atributo gráfico do qual você deseja remover a legenda.

```{r, fig.show='hold', out.width = "50%"}
bp + guides(fill = FALSE)
```

Também é possível remover a legenda utilizando a função `scale_fill_discrite()`. A família `scale_X_Y()` de funções permite escolher manualmente os parâmetros de cada escala utilizada no gráfico.

```{r, fig.show='hold', out.width = "50%"}
bp + scale_fill_discrete(guide = F)
```

O comando a seguir remove todas as legendas, não importa o atributo que ela esteja representando.

```{r}
bp + theme(legend.position="none")
```

## Alterando a ordem dos itens

Para alterar a ordem dos itens na legenda do gráfico no `ggplot2`, usamos o comando da escala de cores.

```{r}
bp + scale_fill_discrete(breaks=c("trt1", "ctrl", "trt2"))
bp
```

Dependendo dos aspectos gráficos (cores, formatos, preenchimentos) especificados, você pode precisar usar alguma das seguintes funções: 

- `scale_fill_manual()`
- `scale_colour_hue()`
- `scale_colour_manual()`
- `scale_shape_discrete()`
- `scale_linetype_discrete()`

Você pode também querer inverter a ordem dos itens da legenda. Isso pode ser feito de uma das seguintes maneiras.

```{r, fig.show='hold', out.width = "50%"}
bp + guides(fill = guide_legend(reverse = TRUE))
bp + scale_fill_discrete(guide = guide_legend(reverse = TRUE))
```

## Removendo os títulos da legenda

Algumas vezes é necessário remover o título das legendas do gráfico feito no `ggplot2`. Veja a seguir algumas maneiras:

```{r, fig.show='hold', out.width = "50%"}
# Remove o título apenas da legenda do preenchimento (fill).
bp + guides(fill=guide_legend(title=NULL))

# Remove o título de todas as legendas.
bp + theme(legend.title = element_blank())
```

## Modificando texto, cores e rótulos

Existem duas formas para modificar os textos e rótulos das legendas. Uma delas é modificar o `data.frame` de forma com que os fatores tenham o mesmo nome que você deseja na legenda. Outra forma é usando as funções `scale_X_Y()`. 

No nosso exemplo, como a variável `group` está associada ao atributo `fill`, usamos as funções `scale_fill_discrete()`. e `scale_fill_manual()`. Utilizamos a primeira se não quisermos alterar as cores padrão, mas sim que cada fator esteja associado uma cor diferente. Mudamos também os rótolos e o título da legenda.

```{r, fig.show='hold', out.width = "50%"}
bp + scale_fill_discrete(name = "Experimental\nCondition",
                         breaks = c("ctrl", "trt1", "trt2"),
                         labels = c("Control", "Treatment 1", "Treatment 2"))
```

Usamos a segunda se quisermos alterar as cores padrão. Aqui, escolhemos as cores da escala hexadecimal. Veja que isso não aletrou o eixo x do gráfico.

```{r, fig.show='hold', out.width = "50%"}
bp + scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"), 
                       name="Experimental\nCondition",
                       breaks=c("ctrl", "trt1", "trt2"),
                       labels=c("Control", "Treatment 1", "Treatment 2"))
```

## Modificando a aparência da legenda

Existem inúmeras modificações que podem ser realizadas na aparência da legenda. Todas elas estão relacionadas à modificação do `element_text()`. Veja neste [link](http://docs.ggplot2.org/0.9.2.1/element_text.html) todos os atributos que podem ser modificados.

```{r}
# Mudando a aparência do título
bp + theme(legend.title = element_text(color = "blue", size = 16, face = "bold"))
```

```{r}
# Mudando a aparência dos rótulos
bp + theme(legend.text = element_text(colour = "blue", size = 16, face = "bold"))
```

## Modificando a posição da legenda

É possível controlar a posição da legenda facilmente escolhendo uma das posições:  `left`, `right`, `top` e `bottom`.

```{r}
bp + theme(legend.position="top")
```

Também é possível controlar a posição da legenda de forma precisa usando a função `theme()`. A legenda será posicionada dentro do gráfico com o ponto central sendo o valor do argumento `legend.position=`. Esses valores são definidos de forma que o ponto (0,0) seja o canto inferior esquerdo e (1,1) seja o canto superior direito.

```{r}
bp + theme(legend.position=c(.5, .5))
```

# Exercícios

--------------------------------------------------------------------------------

**1.** 

O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
```

--------------------------------------------------------------------------------

**2.** 

Mapeie uma variável contínua para uma cor, tamanho e forma. Como essas formas
estéticas se comportam diferente para variáveis categóricas vs contínuas?

--------------------------------------------------------------------------------

**3.**

O que acontece se você rodar `ggplot(data = mtcars)`?

--------------------------------------------------------------------------------

**4.**

Utilizando o `mtcars`, faça um gráfico de dispersão de `mpg` por `qsec`.

--------------------------------------------------------------------------------

**5.**

Utilizando o `mtcars`, o que acontece se você fizer um gráfico de dispersão de `vs` por `mpg`? Por que o gráfico não é útil?

--------------------------------------------------------------------------------
