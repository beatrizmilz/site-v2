---
title: "API"
author: "Curso-R"
date: 2018-07-18
categories: ["R"]
tags: ["API"]
slug: "plumber"
minidesc: "Construa API's para conectar a sua anÃ¡lise com outros programas."
desc: "O fluxo da ciÃªncia de dados se encerra na parte de comunicaÃ§Ã£o. Essa parte Ã© responsÃ¡vel por transferir todo o conhecimento gerado durante a anÃ¡lise de dados. E isso nÃ£o Ã© nada fÃ¡cil. A forma de construir a comunicaÃ§Ã£o depende muito do interlocutor."
requisitos: ["r-base", "dplyr"]
layout: "article"
ordem: 210
---



<div id="introduÃ§Ã£o" class="section level1">
<h1>IntroduÃ§Ã£o</h1>
<p>O fluxo da ciÃªncia de dados se encerra na parte de comunicaÃ§Ã£o. Essa parte Ã© responsÃ¡vel por transferir todo o conhecimento gerado durante a anÃ¡lise de dados. E isso nÃ£o Ã© nada fÃ¡cil!!</p>
<p><img src="/material/api/figures/data-science-communicate.png"></p>
<p>A forma de construir a comunicaÃ§Ã£o depende muito do interlocutor. Por exemplo, se a pessoa que vai receber a comunicaÃ§Ã£o Ã© um tÃ©cnico como vocÃª, Ã© importante elaborar um documento que deixe claro o que vocÃª fez e como vocÃª chegou nos resultados. Por outro lado, se a pessoa que vai receber seus trabalhos for um tomador de decisÃ£o, o desafio Ã© passar os resultados de uma forma intuitiva e impactante.</p>
<p>Mas, e se o interlocutor for um robÃ´? Qual a melhor forma de se comunicar com uma mÃ¡quina?</p>
<p>Nesse material trabalhamos o conceito e aplicaÃ§Ã£o de <em>Application Programming Interfaces</em>, ou APIs. Essa Ã© a forma que as mÃ¡quinas se comunicam nos dias de hoje.</p>
<div id="prÃ©-requisitos" class="section level2">
<h2>PrÃ©-requisitos</h2>
<p>Esse material assume que vocÃª sabe usar <code>dplyr</code> e o <code>%&gt;%</code>, que sabe o que Ã© o <code>RStudio</code> e <code>rmarkdown</code>. Se vocÃª nÃ£o sabe usar essas coisas, veja os materiais em <a href="http://material.curso-r.com/pipe" class="uri">http://material.curso-r.com/pipe</a> e <a href="http://material.curso-r.com/manip" class="uri">http://material.curso-r.com/manip</a>.</p>
<p>TambÃ©m seria interessante ter uma noÃ§Ã£o de pacotes em R e a utilizaÃ§Ã£o do <code>curl</code> (via terminal).</p>
</div>
</div>
<div id="o-que-Ã©-uma-api" class="section level1">
<h1>O que Ã© uma API?</h1>
<p>Para explicar APIs, podemos utilizar a analogia do Matrix. Tem aquela cena:</p>
<p><img src="/material/api/figures/kungfu.gif"></p>
<p>O que o Neo fez aqui? Ele conectou com uma mÃ¡quina, setou no computador o que ele queria aprender, e puxou um curso de Kung Fu.</p>
<p>Agora, imagine que ao invÃ©s de um curso de Kung Fu, vocÃª queira saber o resultado de um modelo preditivo. VocÃª faz o upload de uma base de dados, e recebe um score, por exemplo, um score de crÃ©dito. Ou entÃ£o vocÃª recebe um dado de um servidor de banco de dados. Ou, ainda, vocÃª quebra um CAPTCHA. Melhor do que aprender Kung Fu ğŸ˜„ğŸ˜„ğŸ˜„.</p>
<p>Hoje em dia, a maioria das grandes empresas disponibilizam APIs para anÃ¡lise de dados. Twitter, Facebook, Spotify, Uber e Instagram sÃ£o apenas algumas delas. Num mundo dinÃ¢mico como conhecemos hoje, nÃ£o faz sentido construir do zero um lugar centralizador capaz de fornecer todos os serviÃ§os; os serviÃ§os precisam ser conectados, e a conexÃ£o Ã© feita atravÃ©s de APIs.</p>
<p>Uma vantagem de usar APIs Ã© que ela nÃ£o depende de linguagens. Na verdade, sÃ³ depende de uma linguagem: as requisiÃ§Ãµes web. Em particularmente, Ã© importante saber usar as requisiÃ§Ãµes <code>GET</code> e <code>POST</code>.</p>
<p>Colocando numa casca de noz, usamos <code>GET</code> quando pedimos dados para da mÃ¡quina e <code>POST</code> quando enviamos dados para a mÃ¡quina. Na prÃ¡tica, Ã© possÃ­vel enviar dados para a mÃ¡quina usando <code>GET</code>, e recebemos algo de volta quando usamos <code>POST</code>. A diferenÃ§a Ã© que o <code>POST</code> Ã© mais especializado, permitindo que vocÃª passe os dados para o servidor de diversas maneiras diferentes. AlÃ©m disso, o <code>POST</code> permite a transferÃªncia de dados de forma <em>segura</em>.</p>
<p>Nossa tarefa serÃ¡ montar cÃ³digos que abrem um link para uma pessoa poder chamar usando requisiÃ§Ãµes <code>GET</code> ou <code>POST</code>.</p>
<p>No R, existem duas soluÃ§Ãµes principais para trabalhar com APIs: <code>opencpu</code> e <code>plumber</code>. A diferenÃ§a entre os dois Ã© que o <code>opencpu</code> Ã© um framework mais geral e apresenta diversas formas de resolver problemas de seguranÃ§a e escalabilidade. Enquanto isso, o <code>plumber</code> foi montado para ser simples.</p>
<p>Nesse tutorial, vamos primeiro trabalhar com o <code>plumber</code>, depois com o <code>opencpu</code>. No final, voltaremos ao <code>plumber</code> para uma aplicaÃ§Ã£o mais prÃ¡tica.</p>
<p>Para contextualizar nossa aplicaÃ§Ã£o, utilizaremos um preditor de notas dos filmes do IMDb. Para isso, utilizaremos a base de dados <code>movies</code> do pacote <code>ggplot2movies</code>. Essa base contÃ©m informaÃ§Ãµes das notas e outras caracterÃ­sticas de 58.788 filmes. Para mais detalhes sobre a base, rode <code>?movies</code>.</p>
<p>Se nÃ£o tiver esse pacote, rode <code>install.packages("ggplot2movies")</code>.</p>
<pre class="r"><code>library(tidyverse)
## â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.0 â”€â”€
## âœ“ ggplot2 3.3.0     âœ“ purrr   0.3.4
## âœ“ tibble  3.0.1     âœ“ dplyr   1.0.0
## âœ“ tidyr   1.0.3     âœ“ stringr 1.4.0
## âœ“ readr   1.3.1     âœ“ forcats 0.5.0
## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()
dados &lt;- ggplot2movies::movies %&gt;% 
  filter(!is.na(budget), budget &gt; 0) %&gt;% 
  select(title, year, budget, rating) %&gt;% 
  arrange(desc(year))

dados
## # A tibble: 5,183 x 4
##    title                         year   budget rating
##    &lt;chr&gt;                        &lt;int&gt;    &lt;int&gt;  &lt;dbl&gt;
##  1 90                            2005     4000    9.1
##  2 Alien Abduction               2005   600000    1.9
##  3 All the Stage Is a World      2005    12000    7  
##  4 Alone in the Dark             2005 20000000    2.1
##  5 Amityville Horror, The        2005 18000000    5.8
##  6 And I Lived                   2005    20000    9.4
##  7 Are We There Yet?             2005 32000000    3.5
##  8 Ash Wednesday                 2005     4999    8.6
##  9 Assault on Precinct 13        2005 20000000    6.3
## 10 Ballad of Jack and Rose, The  2005  1500000    6.2
## # â€¦ with 5,173 more rows</code></pre>
<p>Nosso modelo tentarÃ¡ prever <code>rating</code> utilizando as seguintes variÃ¡veis:</p>
<ul>
<li><code>budget</code>: orÃ§amento do filme em dÃ³lares</li>
<li><code>year</code>: ano do filme (considerado como nÃºmero inteiro)</li>
</ul>
<p>O modelo Ã© dado por</p>
<pre class="r"><code>modelo &lt;- lm(rating ~ budget + year, data = dados)
summary(modelo)
## 
## Call:
## lm(formula = rating ~ budget + year, data = dados)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -5.2325 -0.9537  0.1408  1.0482  3.9507 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  1.501e+01  2.040e+00   7.355 2.20e-13 ***
## budget       3.645e-10  9.570e-10   0.381    0.703    
## year        -4.469e-03  1.029e-03  -4.342 1.44e-05 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.541 on 5180 degrees of freedom
## Multiple R-squared:  0.003793,   Adjusted R-squared:  0.003408 
## F-statistic: 9.861 on 2 and 5180 DF,  p-value: 5.318e-05</code></pre>
<p>R^2 de 0.003, nada mal (risos). Agora, vamos montar uma funÃ§Ã£o que prevÃª a nota de um filme com base no seu orÃ§amento e ano.</p>
<pre class="r"><code>funcao_que_preve &lt;- function(orcamento, ano) {
  predict(modelo, newdata = data.frame(budget = orcamento, year = ano))
}</code></pre>
<p>TambÃ©m faremos uma funÃ§Ã£o que retorna uma amostra aleatÃ³ria de dez casos da base de dados</p>
<pre class="r"><code>solta_10 &lt;- function() {
  dados %&gt;% 
    sample_n(10)
}</code></pre>
</div>
<div id="plumber" class="section level1">
<h1>Plumber</h1>
<p>Para criar uma API com o <code>plumber</code>, vocÃª precisa de trÃªs coisas:</p>
<ul>
<li>Uma funÃ§Ã£o que executa uma aÃ§Ã£o</li>
<li>Uma documentaÃ§Ã£o da funÃ§Ã£o</li>
<li>Selecionar uma porta para disponibilizar sua api</li>
</ul>
<p>Por exemplo, para a funÃ§Ã£o <code>solta_10()</code>, bastaria criar um script <code>R/meuscript.R</code> com o conteÃºdo abaixo</p>
<pre class="r"><code>#* @get /solta
solta_10 &lt;- function() {
  dados %&gt;% 
    sample_n(10)
}</code></pre>
<p>ApÃ³s criar esse <code>R/meuscript.R</code>, basta rodar</p>
<pre class="r"><code>p &lt;- plumber::plumb(&#39;R/meuscript.R&#39;)
p$run(port = 8888)</code></pre>
<pre><code>Starting server to listen on port 8888</code></pre>
<p>No momento que vocÃª rodou <code>p$run()</code>, a sua sessÃ£o do R ficou ocupada. O que esse cÃ³digo estÃ¡ fazendo Ã© <em>servir</em> a sua funÃ§Ã£o! Ela serÃ¡ acessÃ­vel pelo seu prÃ³prio computador, atravÃ©s de <a href="http://localhost:8888" class="uri">http://localhost:8888</a>. Para testar, abra uma aba de terminal no RStudio e rode</p>
<pre><code>curl &quot;http://localhost:8888/solta&quot;</code></pre>
<p>No lugar do <code>curl</code> (terminal), vocÃª poderia abrir uma outra sessÃ£o do R e rodar:</p>
<pre class="r"><code>httr::GET(&quot;http://localhost:8888/solta&quot;)</code></pre>
<p>Note que chamamos a funÃ§Ã£o pelo nome que estÃ¡ escrito em <code>#* @get ...</code>.</p>
<p>VocÃª tambÃ©m pode testar a soluÃ§Ã£o copiando o IP do seu servidor e substituir no lugar do <code>localhost</code>. Pronto! vocÃª fez uma API.</p>
<p>Agora, vamos fazer uma API que aceita uma requisiÃ§Ã£o <code>POST</code>. Basta usar a mesma abordagem:</p>
<pre class="r"><code>#* @post /prever
funcao_que_preve &lt;- function(orcamento, ano) {
  d &lt;- data.frame(budget = as.numeric(orcamento), year = as.numeric(ano))
  predict(modelo, newdata = d)
}</code></pre>
<p>Novamente, basta adicionar o cÃ³digo no script <code>R/meuscript.R</code> e rodar com <code>plumb</code>.</p>
<pre class="r"><code>p &lt;- plumber::plumb(&#39;R/meuscript.R&#39;)
p$run(port = 8888)</code></pre>
<p>Agora, vocÃª pode prever a nota do IMDb rodando:</p>
<pre><code>curl --data &quot;orcamento=10000&amp;ano=1991&quot; &quot;http://localhost:8888/prever&quot;</code></pre>
<div id="exercÃ­cios" class="section level2">
<h2>ExercÃ­cios</h2>
<p>Entre na documentaÃ§Ã£o do plumber em <a href="https://www.rplumber.io/" class="uri">https://www.rplumber.io/</a> e leia.</p>
<ol style="list-style-type: decimal">
<li>Lembre que tambÃ©m Ã© possÃ­vel chamar uma funÃ§Ã£o com parÃ¢metros usando <code>GET</code>! Descubra como.</li>
<li>Crie com o <code>plumber</code> uma funÃ§Ã£o <code>plotar</code> que retorna um grÃ¡fico de dispersÃ£o de <code>budget</code> (eixo x) e <code>rating</code> (eixo y). Salve a imagem rodando</li>
</ol>
<pre><code>curl &quot;http://localhost:8888/plotar&quot; &gt; meu_plot.png</code></pre>
</div>
</div>
<div id="opencpu" class="section level1">
<h1>OpenCPU</h1>
<p>O pacote <code>opencpu</code> usa uma lÃ³gica um pouco diferente do <code>plumber</code>. Para o <code>opencpu</code>,</p>
<ul>
<li>todas as funÃ§Ãµes estÃ£o dentro de um <strong>pacote</strong> em R</li>
<li>chamamos as funÃ§Ãµes como se o pacote fosse um site.</li>
<li>usamos <code>GET</code> para obter informaÃ§Ãµes sobre o pacote e suas funÃ§Ãµes</li>
<li>usamos <code>POST</code> para de fato rodar as funÃ§Ãµes</li>
</ul>
<p>Para utilizar o <code>opencpu</code>, primeiro teremos de criar um pacote em R. Se tiver interesse em como criar novos pacotes muito rÃ¡pido, <a href="http://curso-r.com/blog/2017/09/07/2017-09-07-pacote-miojo/">leia esse artigo</a>, Aqui, utilizaremos o cÃ³digo</p>
<pre class="r"><code>devtools::create(&#39;preditorIMDb&#39;)</code></pre>
<p>Dentro da pasta <code>R</code> do pacote <code>preditorIMDb</code>, criaremos um arquivo <code>funs.R</code> com as funÃ§Ãµes definidas anteriormente em <code>R/meuscript.R</code>, mas com uma documentaÃ§Ã£o de pacote no lugar da documentaÃ§Ã£o do <code>plumber</code>:</p>
<pre class="r"><code>#&#39; Solta dez observaÃ§Ãµes
#&#39;
#&#39; A partir de uma base de dados, solta 10 observaÃ§Ãµes aleatÃ³rias
#&#39;
#&#39; @export
solta_10 &lt;- function() {
  dplyr::sample_n(dados, 10)
}

#&#39; PrevÃª o score do filme
#&#39;
#&#39; Com base no orÃ§amento e no ano, solta o rating mÃ©dio de um filme
#&#39; 
#&#39; @param orcamento OrÃ§amento do filme
#&#39; @param ano Ano do filme
#&#39;
#&#39; @export
funcao_que_preve &lt;- function(orcamento, ano) {
  predict(modelo, newdata = data.frame(budget = orcamento, year = ano))
}</code></pre>
<p>Agora precisamos carregar a documentaÃ§Ã£o e instalar o pacote:</p>
<pre class="r"><code># adiciona dependencias de pacotes externos
devtools::use_package(&#39;tidyverse&#39;, pkg = &#39;preditorIMDb&#39;)
devtools::use_package(&#39;ggplot2movies&#39;, pkg = &#39;preditorIMDb&#39;)
# dados
devtools::use_data(modelo, pkg = &#39;preditorIMDb&#39;)
devtools::use_data(dados, pkg = &#39;preditorIMDb&#39;)
# documenta o pacote
devtools::document(&#39;preditorIMDb&#39;)
# instala o pacote na mÃ¡quina
devtools::install(&#39;preditorIMDb&#39;)</code></pre>
<p>Agora podemos rodar nossa API com base no pacote, fazendo</p>
<pre class="r"><code>opencpu::ocpu_start_app(&#39;preditorIMDb&#39;)</code></pre>
<p>Para ver o cÃ³digo da funÃ§Ã£o, basta rodar</p>
<pre><code>curl http://localhost:5656/ocpu/library/preditorIMDb/R/solta_10/print</code></pre>
<p>Para de fato rodar o a funÃ§Ã£o, se sua funÃ§Ã£o nÃ£o tiver parÃ¢metros, rode</p>
<pre><code>curl http://localhost:5656/ocpu/library/preditorIMDb/R/solta_10/json -X POST</code></pre>
<p><strong>ExercÃ­cios</strong>:</p>
<p>Entre na documentaÃ§Ã£o do OpenCPU em <a href="https://www.opencpu.org/api.html" class="uri">https://www.opencpu.org/api.html</a></p>
<ol style="list-style-type: decimal">
<li>O que acontece quando vocÃª roda</li>
</ol>
<pre><code>curl http://localhost:5656/ocpu/library/preditorIMDb/R/solta_10 -X POST</code></pre>
<p>? Explique cada uma dessas saÃ­das</p>
<pre><code>/ocpu/tmp/x0ed707c4a1/R/solta_10
/ocpu/tmp/x0ed707c4a1/R/.val
/ocpu/tmp/x0ed707c4a1/source
/ocpu/tmp/x0ed707c4a1/console
/ocpu/tmp/x0ed707c4a1/info
/ocpu/tmp/x0ed707c4a1/files/DESCRIPTION</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Descubra como rodar uma requisiÃ§Ã£o POST com parÃ¢metros e rode <code>funcao_que_preve(10000, 2004)</code>.</li>
</ol>
<div id="opencpu-gratuito" class="section level2">
<h2>OpenCPU gratuito!</h2>
<p>O <code>opencpu</code> Ã© mais do que um pacote em R! Se vocÃª olhar no site do produto, verÃ¡ que um esforÃ§o enorme foi envidado por seu autor, <a href="https://github.com/jeroen">Jeroen Ooms</a> para desenvolver nÃ£o sÃ³ o pacote como tambÃ©m um software para servir vÃ¡rios aplicativos feitos em R. Com o <strong>software</strong> <code>opencpu</code>, basta vocÃª criar vÃ¡rios pacotes com soluÃ§Ãµes para que elas sejam imediatamente utilizÃ¡veis na forma de APIs.</p>
<p>JÃ¡ pensou se existisse algum ser generoso que criasse um servidor com todos os pacotes do CRAN e disponibilizasse esse recurso online e de graÃ§a para todos? Muito bem, essa pessoa existe, e trata-se do prÃ³prio Jeroen!</p>
<p>Assim, basta acessar <a href="http://cran.ocpu.io" class="uri">http://cran.ocpu.io</a> para ter todos os pacotes do R em suas mÃ£os. Por exemplo, podemos rodar</p>
<pre class="r"><code>r &lt;- httr::POST(&quot;http://cran.ocpu.io/praise/R/praise/json&quot;)
httr::content(r)
## [1] &quot;there is no package called &#39;praise&#39;\n\nIn call:\nfind.package(pkgname, lib.loc = lib.loc)&quot;</code></pre>
<p>(o pacote <code>praise</code> Ã© um gerador de elogios aleatÃ³rio)</p>
<p>E tem mais! Com o serviÃ§o do <code>ocpu.io</code> vocÃª pode vincular sua conta ao GitHub e deixar todos os seus pacotes funcionarem como APIs automaticamente. Veja em <a href="https://www.opencpu.org/cloud.html" class="uri">https://www.opencpu.org/cloud.html</a> como fazer isso.</p>
<p>Por exemplo, o post da Curso-R chamado <a href="http://curso-r.com/blog/2017/08/28/2017-08-27-safadao/">Aquele 1% Ã© deep learning</a> foi montado usando OpenCPU como gerador dos textos do Wesley SafadÃ£o.</p>
<pre class="r"><code>r &lt;- httr::POST(&quot;http://jtrecenti.ocpu.io/safadao/R/gen/json&quot;)
cat(httr::content(r)[[1]])
## 47</code></pre>
</div>
</div>
<div id="plumber-em-produÃ§Ã£o" class="section level1">
<h1>Plumber em produÃ§Ã£o</h1>
<p>Agora vamos mostrar um exemplo que utilizamos em produÃ§Ã£o para quebrar captchas. Vamos estudar o repositÃ³rio <code>api</code> da pÃ¡gina do github <a href="https://github.com/decryptr" class="uri">https://github.com/decryptr</a>. Trata-se de um cÃ³digo que carrega os modelos dos quebradores de CAPTCHA e cria funÃ§Ãµes do tipo <code>predict_*</code> que recebem uma imagem de CAPTCHA e retornam um texto contendo o resultado da classificaÃ§Ã£o.</p>
<p>Por exemplo, o cÃ³digo abaixo, salvo em <code>R/captcha.R</code> serve para carregar o modelo para quebrar o CAPTCHA da receita federal.</p>
<pre class="r"><code>library(magrittr)
library(decryptr)

reticulate::py_available(TRUE)
suppressMessages(suppressWarnings({
  rfb_model &lt;- decryptrModels::read_model(&#39;rfb&#39;)
  trt_model &lt;- decryptrModels::read_model(&#39;trt&#39;)
  tjmg_model &lt;- decryptrModels::read_model(&#39;tjmg&#39;)
  esaj_model &lt;- decryptrModels::read_model(&#39;esaj&#39;)
}))

#* @post /predict_tjmg
predict_tjmg &lt;- function(img) {
  img_decoded &lt;- base64enc::base64decode(img)
  predict(tjmg_model, newdata = decryptr::prepare(img_decoded))
}</code></pre>
<p>Como vimos anteriormente, basta rodar</p>
<pre class="r"><code>p &lt;- plumber::plumb(&#39;R/captcha.R&#39;)
p$run(port = 8888)</code></pre>
<pre class="r"><code>library(decryptr)
arq &lt;- captcha_download_tjmg()</code></pre>
<pre class="r"><code>library(decryptr)
arq &lt;- &quot;figures/captcha5fdb51a0b41b.jpg&quot;
arq %&gt;% 
  read_captcha() %&gt;%
  `[[`(1) %&gt;%
  plot()</code></pre>
<p><img src="/material/api/_index_files/figure-html/unnamed-chunk-19-1.png" width="30%" /></p>
<pre class="bash"><code>(echo -n &#39;{&quot;img&quot;: &quot;&#39;; base64 &quot;captcha5fdb51a0b41b.jpeg&quot;; echo &#39;&quot;}&#39;) |
(curl -s -H &quot;Content-Type: application/json&quot; -d @- http://localhost:8888/predict_tjmg) |
sed &#39;s/[^[:alnum:]]//g&#39;</code></pre>
<pre><code>73563</code></pre>
<p>Ou, em outra sessÃ£o do R</p>
<pre class="r"><code>path &lt;- &#39;captcha5fdb51a0b41b.jpeg&#39;
base64 &lt;- base64enc::base64encode(readr::read_file_raw(path))
r &lt;- httr::POST(&#39;http://localhost:8888/predict_tjmg&#39;, 
                body = list(img = base64), 
                encode = &#39;json&#39;)
httr::content(r, &#39;text&#39;)</code></pre>
</div>
<div id="fazendo-mais-com-o-plumber" class="section level1">
<h1>Fazendo mais com o plumber</h1>
<p>O <code>plumber</code> tambÃ©m pode ser utilizado numa soluÃ§Ã£o Docker. O Docker Ã© um serviÃ§o de containers, e um container Ã© uma espÃ©cie de mÃ¡quina virtual que roda somente a sua aplicaÃ§Ã£o.</p>
<p>A vantagem de usar Docker Ã© que vocÃª seria capaz de instalar sua API em qualquer servidor, sem precisar configurar muitas coisas na mÃ¡quina.</p>
<p>Para ver como usar plumber com Docker, siga a documentaÃ§Ã£o deste <a href="https://www.rplumber.io/docs/hosting.html#docker">link</a>.</p>
</div>
